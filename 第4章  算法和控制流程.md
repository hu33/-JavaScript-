## 第4章  算法和控制流程

算法和数据结构对程序性能的重要性就不用说了，直接入正题~！这章主要从循环、条件语句和递归三个方面阐述优化点。

### 循环

JS提供了四种循环（ES5之前），for、while、do-while、for-in，其中只有for-in比其他几种明显要慢，其余三种性能都差不多，所以循环类型的选择应该是基于需求而不是性能。要考虑循环性能的话，得从每次迭代处理的事务和迭代的次数两个方面去考虑。

#### 优化点1  减少迭代的工作量

灰常明显，如果一次循环迭代花的时间少了，那么多次循环花的时间就更少了，所以最好限制循环中耗时操作的数量：

- 减少对象成员及数组项的查找次数，比如下例：

  ```javascript
  for(var i; i < arr.length; i++) {}   //每次循环都要查找一次arr.length
  for(var i, len = arr.length; i < len; i++) {}    //整个迭代只需要查找一次arr.length
  ```

- 颠倒数组的顺序，比如下例：

  ```javascript
  for(var i, len = arr.length; i < len; i++) {}  //这里的控制条件其实比较了两次，迭代数是否少于总数，它是否为true
  for(var i = arr.length; i--; ) {} //将减法放到了控制条件中，每个控制条件只是简单地与0进行比较
  ```

#### 优化点2  减少迭代次数

最广为人知的一个方式就是“达夫设备”了，它的基本理念是：每次循环最多可调用8次循环体，那么循环迭代次数就为总数除以8。当然，这个方式是当迭代次数很大的时候才看得到效果啦。

```javascript
var i = arr.length % 8;
while(i) {
  process(arr[i--]);
}
i = Math.floor(arr.length / 8);
while(i) {
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
  process(arr[i--]);
}
```

#### 优化点3  能用基于循环的迭代就不要用基于函数的迭代了

forEach()这种方法可以遍历数组所有成员，并在每个成员上执行一个函数，这个方法用起来是比较便利，但是它毕竟慢，毕竟每个数组项要调用外部方法，这是要产生开销的。

### 条件语句

条件语句主要有if-else和switch，通常来讲，if-else适用于判断两个离散值或几个不同的值域，switch适用于判断多于两个离散值的情况。从性能上讲，大多数情况下，switch是要比if-else快的，一个是因为很多语言对switch做了分支表索引的优化，另一方面是因为JS中switch语句比较值时使用全等进行判断，避免了类型转换时的损耗。

#### 优化点4  优化if-else时，最小化到达正确分支前所需判断的条件数量

- if-else中的条件语句应该总是按照从最大概率到最小概率的顺序排列
- 将if-else组织成一系列嵌套的if-else语句



未完待续......



